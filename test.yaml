name: Toolbox
description: Toolbox
host: WORD
api_set: {}
script:
  content: >+
    let openAIKey = localStorage.getItem("openAIKey") || "";

    let openAIUrl = localStorage.getItem("openAIUrl") || "";

    let stopExecution = false;


    document.addEventListener("DOMContentLoaded", function() {
      const apiKeyInputContainer = document.getElementById("apiKeyInputContainer");
      const apiUrlInputContainer = document.getElementById("apiUrlInputContainer");
      const mainLayout = document.getElementById("mainLayout");
      const merchantCommentsLayout = document.getElementById("merchantCommentsLayout");

      if (openAIKey && openAIUrl) {
        if (apiKeyInputContainer) apiKeyInputContainer.style.display = "none";
        if (apiUrlInputContainer) apiUrlInputContainer.style.display = "none";
      }

      // Add event listener for Atome Merchant contract check button
      document.getElementById("atomeMerchantContractCheckButton").addEventListener("click", function() {
        mainLayout.style.display = "none";
        merchantCommentsLayout.style.display = "block";
      });

      // Add event listener for Back button
      document.getElementById("backButton").addEventListener("click", function() {
        merchantCommentsLayout.style.display = "none";
        mainLayout.style.display = "block";
      });

      document.getElementById("submitCommentButton").addEventListener("click", async function() {
        document.getElementById("gptResponseOutput").value = ""; // Clear the answer text box
        await atomemerchantplaybook();
      });
    });


    document.getElementById("saveApiKeyButton").addEventListener("click",
    function() {
      openAIKey = document.getElementById("apiKeyInput").value;
      localStorage.setItem("openAIKey", openAIKey);
      alert("API Key saved");
    });


    document.getElementById("saveApiUrlButton").addEventListener("click",
    function() {
      openAIUrl = document.getElementById("apiUrlInput").value;
      localStorage.setItem("openAIUrl", openAIUrl);
      alert("API URL saved");
    });


    document.getElementById("eraseCredentialsButton").addEventListener("click",
    function() {
      localStorage.removeItem("openAIKey");
      localStorage.removeItem("openAIUrl");
      openAIKey = "";
      openAIUrl = "";
      document.getElementById("apiKeyInputContainer").style.display = "block";
      document.getElementById("apiUrlInputContainer").style.display = "block";
      alert("API credentials erased");
    });


    document.getElementById("hardStopButton").addEventListener("click",
    function() {
      alert("Stopping execution");
      stopExecution = true;
    });



    async function callOpenAI(systemPrompt, handleOutput) {
      stopExecution = false; // Reset the flag at the start of the function

      if (!openAIKey || !openAIUrl) {
        alert("Please enter and save your OpenAI API key and URL.");
        return;
      }

      try {
        await Word.run(async (context) => {
          const selection = context.document.getSelection();
          context.load(selection, "text");
          await context.sync();

          let textToSend = selection.text;

          if (textToSend.length === 0) {
            const body = context.document.body;
            context.load(body, "text");
            await context.sync();
            textToSend = body.text;
          }

          const chunkSize = 8000; // Define larger chunk size
          const textChunks = [];

          // Break text into chunks at paragraph boundaries
          let paragraphs = textToSend.split("\n");
          let currentChunk = "";
          paragraphs.forEach((paragraph) => {
            if (currentChunk.length + paragraph.length + 1 > chunkSize) {
              textChunks.push(currentChunk);
              currentChunk = paragraph;
            } else {
              currentChunk += (currentChunk ? "\n" : "") + paragraph;
            }
          });
          if (currentChunk) {
            textChunks.push(currentChunk);
          }

          const responses = [];
          for (let i = 0; i < textChunks.length; i++) {
            if (stopExecution) {
              console.log("Execution stopped by user");
              throw new Error("Script execution stopped by user");
            }

            const chunk = textChunks[i];
            const cfg = {
              apiVersion: "2024-04-01-preview",
              modelName: "gpt4",
              message: chunk,
              apiKey: openAIKey,
              endPoint: openAIUrl,
              stream: false
            };

            const bodyContent = JSON.stringify({
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: cfg.message }
              ],
              stream: cfg.stream
            });

            console.log("sending to GPT the following content:", bodyContent);

            let response;
            for (let attempt = 0; attempt < 10; attempt++) {
              try {
                response = await fetch(
                  `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${cfg.apiKey}`
                    },
                    body: bodyContent
                  }
                );

                console.log("Fetch response status:", response.status, response.statusText);

                if (response.ok) {
                  break;
                } else {
                  console.error(`Attempt ${attempt + 1} failed: ${response.statusText}`);
                  if (attempt < 9) {
                    await new Promise((resolve) => setTimeout(resolve, 5000 * Math.pow(2, attempt)));
                  }
                }
              } catch (error) {
                console.error(`Attempt ${attempt + 1} error:`, error);
                if (attempt < 9) {
                  await new Promise((resolve) => setTimeout(resolve, 5000 * Math.pow(2, attempt)));
                }
              }
            }

            if (!response || !response.ok) {
              const errorText = response ? await response.text() : "No response";
              console.error("Response error text:", errorText);
              throw new Error(`Failed to fetch from OpenAI: ${response.statusText} - ${errorText}`);
            }

            const result = await response.json();
            console.log("Response JSON received:", result);

            let output;
            if (result.msg) {
              output = result.msg;
            } else if (result.choices && result.choices.length > 0) {
              output = result.choices[0].message.content;
            } else {
              throw new Error("Invalid response structure");
            }

            responses.push(output);

            // Pause for 1 second after every 5 API calls
            if ((i + 1) % 5 === 0) {
              console.log("Pausing for 1 second after 5 API calls");
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
          }

          const finalOutput = responses.join("\n\n");
          handleOutput(finalOutput);
        });
      } catch (error) {
        console.error("Error in callOpenAI:", error);
        alert("Error: " + error.message);
      }
    }


    async function appendOutputToDocument(output, isFirstChunk) {
      await Word.run(async (context) => {
        const body = context.document.body;

        if (isFirstChunk) {
          body.insertParagraph("", Word.InsertLocation.end); // Add a blank line before the GPT output
          body.insertParagraph("--- GPT output ---", Word.InsertLocation.end);
        }

        const paragraphs = output.split("\n");

        for (const paragraph of paragraphs) {
          const cleanParagraph = paragraph.replace(/\*\*/g, ""); // Remove '**'
          body.insertParagraph(cleanParagraph, Word.InsertLocation.end);
        }

        await context.sync();
      });
    }


    async function searchAndComment(output) {
      await Word.run(async (context) => {
        const selection = context.document.getSelection();
        context.load(selection, "text");
        await context.sync();

        const cleanOutput = output.replace(/\*\*/g, ""); // Remove '**'

        if (selection.text.length > 0) {
          selection.insertComment(cleanOutput, { author: "OpenAI GPT", initials: "GPT" });
          await context.sync();
          console.log("Comment added successfully.");
        } else {
          await appendOutputToDocument(cleanOutput, true);
        }
      });
    }


    function leadershipReviewer() {
      callOpenAI(
        "Make an assessment on whether or not the information should be submitted as it is to the Leader. Assume this is a submission by the Legal team. Rate from 0 to 5 and explain the reasoning. If it not a 5, rewrite to make it as a 5.",
        searchAndComment
      );
    }


    function bulletPointSummarizer() {
      callOpenAI(
        "Summarize the content and present it in bullet points. Ensure it is short to the point, only the essence. Max word per sentence: 14",
        searchAndComment
      );
    }


    function articleWriter() {
      callOpenAI(
        "As per the instructions provided, draft a clause that includes all essential elements.",
        searchAndComment
      );
    }


    function translateToIndonesian() {
      callOpenAI("Translate the following text to Bahasa Indonesia.", searchAndComment);
    }


    function translateToThai() {
      callOpenAI("Translate the following text to Thai.", searchAndComment);
    }


    function fixLegalEnglish() {
      callOpenAI("Improve the legal English in the following text to make it clearer and more precise.", searchAndComment);
    }


    function ExplainLegalEnglish() {
      callOpenAI("Explain in simpler terms. No more than 15 words per sentence", searchAndComment);
    }


    document.getElementById("leadershipReviewerButton").addEventListener("click",
    leadershipReviewer);

    document.getElementById("bulletPointSummarizerButton").addEventListener("click",
    bulletPointSummarizer);

    document.getElementById("articleWriterButton").addEventListener("click",
    articleWriter);

    document.getElementById("fixLegalEnglishButton").addEventListener("click",
    fixLegalEnglish);

    document.getElementById("ExplainLegalEnglishButton").addEventListener("click",
    ExplainLegalEnglish);


    // New functions for batched translation

    async function callOpenAIForTranslation(content, targetLanguage, retryCount
    = 10, initialDelay = 5000) {
      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const cfg = {
            apiVersion: "2024-04-01-preview",
            modelName: "gpt4",
            message: content,
            apiKey: openAIKey,
            endPoint: openAIUrl,
            stream: false,
            top_p: 0,
            temperature: 0
          };

          // console.log(`Calling OpenAI for translation to ${targetLanguage} with config:`, cfg);

          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  {
                    role: "system",
                    content: `Translate the following content to ${targetLanguage}. Keep paragraph delimiters (\\r\\n, \\r, or \\n) in the output.`
                  },
                  { role: "user", content: cfg.message }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          console.log("Fetch response status:", response.status);

          if (response.ok) {
            const result = await response.json();
            console.log(`OpenAI translation result to ${targetLanguage}:`, result);
            return result.choices[0].message.content;
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI for translation to ${targetLanguage} (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }


    async function createTableWithBatchedTranslation(targetLanguage) {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          context.load(body, "text");
          await context.sync();

          const originalText = body.text;
          console.log("Original document text:", originalText);

          // Split the document content into paragraphs
          const paragraphs = originalText.split(/\r\n|\r|\n/).filter((p) => p.trim().length > 0);
          const paragraphCount = paragraphs.length;
          console.log("Number of paragraphs:", paragraphCount);

          // Clear the document content
          body.clear();

          // ----
          // Ensure all content types are removed
          const contentControls = body.contentControls;
          contentControls.load();
          await context.sync();

          contentControls.items.forEach((contentControl) => contentControl.delete());
          await context.sync();

          const tables = body.tables;
          tables.load();
          await context.sync();

          while (tables.items.length > 0) {
            tables.items[0].delete();
            await context.sync();
          }

          const images = body.inlinePictures;
          images.load();
          await context.sync();

          images.items.forEach((image) => image.delete());
          await context.sync();

          console.log("Document content cleared.");

          // Reset styles
          const paragraphsInBody = body.paragraphs;
          paragraphsInBody.load();
          await context.sync();

          paragraphsInBody.items.forEach((paragraph) => {
            paragraph.style = "Normal";
            paragraph.font.set({
              name: "Calibri",
              size: 11,
              color: "000000"
            });
          });
          await context.sync();

          console.log("Document styles reset to default.");

          // ----

          // Prepare for translation in batches
          const batchSize = 2;

          for (let i = 0; i < paragraphCount; i += batchSize) {
            if (stopExecution) {
              console.log("Execution stopped by user.");
              return;
            }

            const batch = paragraphs.slice(i, i + batchSize).join("\n");
            console.log(`Translating batch ${i / batchSize + 1}:`, batch);
            const translatedBatch = await callOpenAIForTranslation(batch, targetLanguage);

            if (translatedBatch) {
              const translatedParagraphs = translatedBatch.split(/\r\n|\r|\n/).filter((p) => p.trim().length > 0);
              console.log(`Number of translated paragraphs: ${translatedParagraphs.length}`);

              // Ensure the lengths of paragraphs and translatedParagraphs match
              for (let j = 0; j < translatedParagraphs.length; j++) {
                if (i + j < paragraphCount) {
                  const originalParagraph = paragraphs[i + j] || "";
                  const translatedParagraph = translatedParagraphs[j] || "";

                  // Check if the original paragraph and the translated paragraph are both non-empty
                  if (originalParagraph.trim() !== "" || translatedParagraph.trim() !== "") {
                    console.log(`Original Paragraph ${i + j}:`, originalParagraph);
                    console.log(`Translated Paragraph ${i + j}:`, translatedParagraph);

                    const table = body.insertTable(1, 2, Word.InsertLocation.end, [
                      [originalParagraph, translatedParagraph]
                    ]);
                    body.insertParagraph("", Word.InsertLocation.end);

                    await context.sync();
                  }
                }
              }
            } else {
              console.log("Failed to translate batch:", batch);
              alert("Translation failed. Please try again later.");
              return;
            }
          }

          console.log("Tables created with preloaded paragraphs and translations.");
        });
      } catch (error) {
        console.error("Error in createTableWithBatchedTranslation:", error);
        alert("Error: " + error.message);
      }
    }


    document.getElementById("translateToChineseButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("Chinese");
    });


    document.getElementById("translateToIndonesianButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("Indonesian");
    });


    document.getElementById("translateToEnglishButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("English");
    });


    document.getElementById("translateToThaiButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("Thai");
    });



    async function selectText(targetText) {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          const searchResults = body.search(targetText, { matchCase: false, matchWholeWord: false });
          context.load(searchResults, "items");
          await context.sync();

          if (searchResults.items.length > 0) {
            const range = searchResults.items[0];
            range.select("Start");
            await context.sync();
            console.log(`Selected "${targetText}" in the document.`);

            // Add a comment to the selected text
            range.insertComment("test", { author: "GPT-Assistant", initials: "GA" });
            await context.sync();
            console.log("Comment added successfully.");
          } else {
            console.log(`Text "${targetText}" not found.`);
          }
        });
      } catch (error) {
        console.error("Error in selectText:", error);
        alert("Error: " + error.message);
      }
    }


    const detailedChecklist = [
      {
        id: 1,
        risk: "Unlimited Liability",
        description:
          "Clauses that impose liability on the Seller for all damages arising out of or in connection with the Agreement.",
        example: "Seller will be liable for all damages arising out of or in connection with the Agreement."
      },
      {
        id: 2,
        risk: "Unfair Termination Rights",
        description: "Clauses that allow the Buyer to terminate the Agreement at any time without cause.",
        example: "Buyer may terminate the Agreement at any time without cause."
      },
      {
        id: 3,
        risk: "Intellectual Property Rights Infringement",
        description:
          "Clauses that require the Seller to indemnify the Buyer against all claims of intellectual property infringement.",
        example: "Seller will indemnify Buyer against all claims of IP infringement."
      },
      {
        id: 4,
        risk: "Unreasonable Warranty Obligations",
        description: "Clauses that impose unreasonable warranty obligations on the Seller.",
        example: "Seller warrants that the services will be free from defects for a period of 5 years."
      },
      {
        id: 5,
        risk: "Unfair Confidentiality Obligations",
        description: "Clauses that require the Seller to keep all information confidential indefinitely.",
        example: "Seller must keep all information confidential indefinitely."
      },
      {
        id: 6,
        risk: "Unfair Non-Compete Clause",
        description:
          "Clauses that restrict the Seller from providing similar services to any other company for an unreasonable period.",
        example: "Seller may not provide similar services to any other company for a period of 5 years."
      },
      {
        id: 7,
        risk: "Unreasonable Indemnification Obligations",
        description: "Clauses that require the Seller to indemnify the Buyer for any and all claims, regardless of fault.",
        example: "Seller indemnifies Buyer for any and all claims, regardless of fault."
      },
      {
        id: 8,
        risk: "Unfair Dispute Resolution Clause",
        description: "Clauses that require all disputes to be resolved in the Buyer’s home jurisdiction.",
        example: "All disputes will be resolved in the Buyer's home jurisdiction."
      },
      {
        id: 9,
        risk: "Unreasonable Service Level Agreements",
        description: "Clauses that impose unreasonable service level agreements on the Seller.",
        example: "Seller must maintain 99.999% uptime."
      },
      {
        id: 10,
        risk: "Unfair Force Majeure Clause",
        description: "Clauses that do not excuse the Seller from performance in the event of a force majeure.",
        example: "Force majeure does not excuse Seller from performance."
      },
      {
        id: 11,
        risk: "Unreasonable Audit Rights",
        description: "Clauses that allow the Buyer to audit the Seller at any time without notice.",
        example: "Buyer may audit Seller at any time without notice."
      },
      {
        id: 12,
        risk: "Unfair Payment Terms",
        description: "Clauses that impose unfair payment terms on the Seller.",
        example: "Payment is due 90 days after invoice date."
      },
      {
        id: 13,
        risk: "Unreasonable Insurance Requirements",
        description: "Clauses that require the Seller to maintain unreasonable amounts of liability insurance.",
        example: "Seller must maintain $10 million in liability insurance."
      },
      {
        id: 14,
        risk: "Unfair Assignment Clause",
        description: "Clauses that allow the Buyer to assign the Agreement without the Seller’s consent.",
        example: "Buyer may assign the Agreement without Seller's consent."
      },
      {
        id: 15,
        risk: "Unreasonable Data Security Requirements",
        description: "Clauses that require the Seller to comply with all data security standards, regardless of cost.",
        example: "Seller must comply with all data security standards, regardless of cost."
      },
      {
        id: 16,
        risk: "Unfair Change Control Process",
        description:
          "Clauses that allow the Buyer to make changes to the services at any time without the Seller’s consent.",
        example: "Buyer may make changes to the services at any time without Seller's consent."
      },
      {
        id: 17,
        risk: "Unreasonable Subcontracting Restrictions",
        description: "Clauses that restrict the Seller from subcontracting without the Buyer’s consent.",
        example: "Seller may not subcontract without Buyer's consent."
      },
      {
        id: 18,
        risk: "Unfair Default Clause",
        description: "Clauses that consider any breach by the Seller as a default.",
        example: "Any breach by Seller constitutes a default."
      },
      {
        id: 19,
        risk: "Unreasonable Compliance Obligations",
        description: "Clauses that require the Seller to comply with all laws in the Buyer’s jurisdiction.",
        example: "Seller must comply with all laws in Buyer's jurisdiction."
      },
      {
        id: 20,
        risk: "Unfair Pricing Adjustments",
        description: "Clauses that allow the Buyer to adjust pricing at any time.",
        example: "Buyer may adjust pricing at any time."
      }
    ];


    const systemPrompt = `

    You are a contract review assistant. Your task is to identify risks in the
    given paragraph that match any of the following list. 

    For each risk, I have provided a detailed description and an example.
    Respond with the ID of the risk if a perfect match is found, otherwise
    return 0.

    Checklist:

    ${detailedChecklist
      .map((item) => `- ID: ${item.id} - ${item.risk}: ${item.description}\nExample: ${item.example}`)
      .join("\n\n")}
    Example:

    1

    `;


    async function checkParagraphForRisks(paragraph, retryCount = 10,
    initialDelay = 60000) {
      const userPrompt = paragraph;

      const cfg = {
        apiVersion: "2024-04-01-preview",
        modelName: "gpt4",
        systemPrompt: systemPrompt,
        userPrompt: userPrompt,
        apiKey: openAIKey,
        endPoint: openAIUrl,
        stream: false,
        top_p: 0,
        temperature: 0
      };

      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  { role: "system", content: cfg.systemPrompt },
                  { role: "user", content: cfg.userPrompt }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          if (response.ok) {
            const result = await response.json();
            console.log(`Result from GPT: ${result}`);

            return result.choices[0].message.content.trim();
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }


    async function scanAndComment() {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          const paragraphs = body.paragraphs;
          context.load(paragraphs, "items");
          await context.sync();

          for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            const range = paragraph.getRange();
            context.load(range, "text");
            await context.sync();

            const text = range.text.trim().replace(/\s+/g, "");
            const isChinese = /[\u4e00-\u9fa5]/.test(text);
            const isJapanese = /[\u3040-\u30FF\u4E00-\u9FAF]/.test(text);

            if (isChinese || isJapanese) {
              // Count characters for Chinese
              if (text.length < 12) {
                continue;
              }
            } else {
              // Count words for other languages
              const wordCount = range.text.trim().split(/\s+/).length;
              if (wordCount < 5) {
                continue;
              }
            }

            console.log(
              `Text length or word count for paragraph ${i + 1}:`,
              isJapanese ? text.length : range.text.trim().split(/\s+/).length
            );

            range.select();
            await context.sync();

            const result = await checkParagraphForRisks(range.text);
            console.log(`Querying GPT for paragraph: ${range.text}`);
            console.log(`Result from GPT: ${result}`);

            if (result && result !== "0") {
              const riskId = parseInt(result, 10);
              const risk = detailedChecklist.find((item) => item.id === riskId);
              if (risk) {
                range.insertComment(`Risk: ${risk.risk}`, { author: "GPT-Assistant", initials: "GA" });
                await context.sync();
              }
            }

            console.log(`Processed paragraph ${i + 1}`);
          }
        });
      } catch (error) {
        console.error("Error in scanAndComment:", error);
        alert("Error: " + error.message);
      }
    }


    document.getElementById("scanAndCommentButton").addEventListener("click",
    scanAndComment);


    async function callOpenAIForPlaybookCheck(systemPrompt, userPrompt,
    retryCount = 10, initialDelay = 60000) {
      const cfg = {
        apiVersion: "2024-04-01-preview",
        modelName: "gpt4",
        systemPrompt: systemPrompt,
        userPrompt: userPrompt,
        apiKey: openAIKey,
        endPoint: openAIUrl,
        stream: false,
        top_p: 0,
        temperature: 0
      };

      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  { role: "system", content: cfg.systemPrompt },
                  { role: "user", content: cfg.userPrompt }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          if (response.ok) {
            const result = await response.json();
            console.log(`Result from GPT: ${result}`);

            return result.choices[0].message.content.trim();
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            alert("Error: " + error.message);
            return null;
          }
        }
      }
    }


    const playbook = [
      { id: 1, rule: "CLIENT and ADVANCE AI will work together to complete the onboarding process." },
      {
        id: 2,
        rule: "CLIENT agrees to cooperate with and follow instructions from ADVANCE AI during the onboarding process."
      },
      { id: 3, rule: "ADVANCE AI will provide services to CLIENT starting from the Go-Live Date." },
      { id: 4, rule: "ADVANCE AI will give CLIENT access credentials for the Services." },
      { id: 5, rule: "ADVANCE AI can only give access credentials to CLIENT's nominated representatives." },
      { id: 6, rule: "CLIENT agrees not to share access credentials with unauthorized third parties or staff." },
      { id: 7, rule: "ADVANCE AI can change, improve, or temporarily stop the Services at any time and for any reason." },
      { id: 8, rule: "ADVANCE AI retains all rights not specifically granted to CLIENT." },
      { id: 9, rule: "ADVANCE AI can introduce new products or services to complement the existing services." },
      { id: 10, rule: "CLIENT acknowledges the risk of Services demanding computing resource." },
      {
        id: 11,
        rule:
          "ADVANCE AI has the right to deny or restrict access to its services to any person without providing a reason."
      },
      { id: 12, rule: "Limited support may be provided by ADVANCE AI as part of the Services." },
      {
        id: 13,
        rule: "CLIENT is responsible for managing connectivity to ADVANCE AI's data centers or computing resources."
      },
      {
        id: 14,
        rule:
          "CLIENT must appoint up to two IT personnel as technical support contacts for communication with ADVANCE AI regarding the Services."
      },
      {
        id: 15,
        rule:
          "CLIENT must provide ADVANCE AI with necessary information, assistance, and cooperation for providing the services."
      },
      {
        id: 16,
        rule:
          "CLIENT will provide or arrange access to all necessary resources and facilities for ADVANCE AI to deliver the services effectively."
      },
      {
        id: 17,
        rule:
          "CLIENT will handle end-user support for its personnel and customers, only involving ADVANCE AI when needed for problem escalation."
      },
      {
        id: 18,
        rule: "CLIENT must attempt to resolve problems using available documentation before reporting them to ADVANCE AI."
      },
      { id: 19, rule: "CLIENT needs internet access to communicate electronically with ADVANCE AI." },
      {
        id: 20,
        rule:
          "CLIENT can request changes to the existing services by submitting a written Change Request to ADVANCE AI via email."
      },
      {
        id: 21,
        rule:
          "ADVANCE AI will review and evaluate Change Requests, and then decide whether to refuse or accept them based on its capability."
      },
      { id: 22, rule: "Parties must discuss and agree on any requested changes." },
      {
        id: 23,
        rule:
          "ADVANCE AI's refusal of a change request or failure to agree on it will not be seen as a violation of the agreement or a reason for termination."
      },
      {
        id: 24,
        rule:
          "ADVANCE AI is not responsible for any losses or damages that may occur from using third party content, services, facilities, or functions in connection with the Services."
      },
      {
        id: 25,
        rule:
          "CLIENT agrees to enter into agreements, including End User Licensing Agreements, for any Third Party Material provided with the Services as required by ADVANCE AI."
      },
      {
        id: 26,
        rule:
          "ADVANCE AI is not obligated to provide access to third-party materials if the owner/licensor stops their services."
      }
    ];


    const tableData = [
      ["ID", "Provision from Template"],
      [
        "1",
        "1.1 The Parties shall endeavour to complete the onboarding process and CLIENT shall use best efforts to cooperate with the onboarding process, provided that ADVANCE AI may, in its sole discretion, with written notice to CLIENT, suspend such onboarding process, or the Services if CLIENT, or any of staff of CLIENT, are under investigation for a criminal offence involving fraud, dishonesty, mismanagement or moral turpitude under any applicable law or regulation a breach of any applicable laws, regulations, codes, or guidelines."
      ],
      [
        "2",
        "1.2 CLIENT will cooperate and abide with reasonable directions from ADVANCE AI in relation to the onboarding process. CLIENT will provide ADVANCE AI with information as may be reasonably requested by ADVANCE AI."
      ],
      [
        "3",
        "1.3 ADVANCE AI shall provide the Services to CLIENT from the Go-Live Date (date inclusive), subject to any conditions as stated in this Agreement and agreed in writing between the Parties."
      ],
      [
        "4",
        "1.4 ADVANCE AI shall provide CLIENT with access credentials for CLIENT to access the Services. CLIENT shall nominate in writing one representative who shall be provided with the access credentials, and provide ADVANCE AI with all relevant information for ADVANCE AI to provide CLIENT with access to the Services."
      ],
      [
        "5",
        "1.5 ADVANCE AI shall only provide the access credentials to the nominated representatives of CLIENT, and has the right to revoke access, suspend the Services, or do any act in its sole and absolute discretion for the purpose of information security, in the event that ADVANCE AI has any reasonable suspicion that the access credentials were subject to any unauthorised usage."
      ],
      [
        "6",
        "1.6 CLIENT agrees that the access credentials shall not be shared with any unauthorised third parties or with any other staff. ADVANCE AI shall not be held liable for any matter in relation to an unauthorised use of access credentials."
      ],
      [
        "7",
        "2.1 ADVANCE AI reserves the right to, at any time and for any reason, modify, enhance or suspend the Services, or any part thereof."
      ],
      [
        "8",
        "2.2 All rights not expressly granted to CLIENT are for all purposes reserved to ADVANCE AI and/or persons authorized by ADVANCE AI."
      ],
      [
        "9",
        "2.3 ADVANCE AI may from time to time offer specific or new products, features, functionalities and/or services to complement or supplement the product/service offerings comprised within the Services. The Parties shall agree on such additional or separate terms & conditions that apply to such products, features, functionalities and/or services."
      ],
      [
        "10",
        "2.4 CLIENT acknowledges and agrees that there is a risk that the Services may be demanding on its computing resources. ADVANCE AI shall not be liable for any Losses arising out of or in connection with such events."
      ],
      [
        "11",
        "2.5 ADVANCE AI shall have the absolute right and discretion to deny or restrict access to or use of the Services by any particular person without ascribing any reasons whatsoever. In such circumstances, ADVANCE AI shall not be liable or held responsible to any party for denying or restricting access to or use of the Services."
      ],
      [
        "12",
        "2.6 Certain limited support, limited to ADVANCE AI providing CLIENT with testing license keys, or any other assistance that ADVANCE AI may provide from time to time, may be provided during and as part of the Services. The Services do not include ongoing training, on-site support, human verification or advisory of any Output, or other ad-hoc services or requests. If CLIENT requires such services from ADVANCE AI, additional fees may be separately chargeable by ADVANCE AI. ADVANCE AI may also deny or delay such services depending on ADVANCE AI’s operational requirements and resource availability."
      ],
      [
        "13",
        "a) CLIENT shall be responsible for procuring and maintaining all network connections and telecommunications links from CLIENT’s systems to ADVANCE AI’s data centres or computing resources, and for all problems, conditions, delays, delivery failures and all other loss or damage arising from or relating to CLIENT’s network connections or telecommunications links or caused by the internet;"
      ],
      [
        "14",
        "b) CLIENT shall designate up to two (2) employees as technical support contacts. The technical support contacts must be information technology (IT) personnel with relevant IT knowledge and experience. ADVANCE AI reserves the right to communicate only with CLIENT’s appointed technical support contacts regarding the Services;"
      ],
      [
        "15",
        "c) CLIENT shall provide ADVANCE AI with all information, assistance and co-operation as reasonably required for the purposes of providing the Services;"
      ],
      [
        "16",
        "d) CLIENT shall provide ADVANCE AI or procure for ADVANCE AI all such access to personnel, land, buildings, premises, facilities, servers, networking equipment, operating systems, data storage and data processing equipment, computing environments, whether or not controlled by CLIENT, as reasonably required by ADVANCE AI for the purposes of providing the Services;"
      ],
      [
        "17",
        "e) CLIENT shall provide end-user support to its own personnel and customers and escalate problems to ADVANCE AI only as and when necessary;"
      ],
      [
        "18",
        "f) CLIENT shall use all documentation available (including online or printed documentation) to resolve problems before reporting them to ADVANCE AI; and"
      ],
      [
        "19",
        "g) CLIENT must have an internet connection and must be able to send and receive electronic communications from ADVANCE AI."
      ],
      [
        "20",
        'a) CLIENT may make request to change, modify or add to the existing Services ("Change Request") by submitting a written Change Request to ADVANCE AI by way of email for ADVANCE AI’s review. The Change Request shall describe, including but not limited to: the type, schedules, reasons of such change, modification or addition and any other information as agreed between the Parties.'
      ],
      [
        "21",
        "b) Upon receipt of a Change Request, and the necessary information as required under a Change Request, ADVANCE AI shall review and evaluate the Change Request and, at its sole and absolute discretion, provide a written refusal or statement of its capability to perform the Change Request."
      ],
      [
        "22",
        "c) Parties shall discuss the Change Request (including but not limited to the scope, type and schedule) and agree on the additional fee and payment procedure for such Change Request. ADVANCE AI will perform or provide the Change Request only upon mutual agreement between the Parties of such Change Request and its additional fee."
      ],
      [
        "23",
        "d) Either ADVANCE AI’s refusal of the Change Request or the Parties’ failure to reach an agreement pertaining to the Change Request shall not constitute or in any way interpreted as ADVANCE AI’s violation or non-performance to this Agreement or a ground for termination of this Agreement."
      ],
      [
        "24",
        'a) The Services may use, require, facilitate access to, be provided by or made available through third party content, services, facilities and functions, (collectively, "Third Party Material"). ADVANCE AI does not control such third party content, services, facilities and functions and will not be held liable for any losses, damage, costs, fees or expenses arising out of or in connection with the use of such Third Party Material.'
      ],
      [
        "25",
        "b) Where required by ADVANCE AI and in relation to any Third Party Material provided with the Services, CLIENT will accept and enter into agreements (for such third party software, products or content) which ADVANCE AI may from time to time present to CLIENT, including but not limited to any End User Licensing Agreements (EULAs) from the proprietors or distributors of third party software."
      ],
      [
        "26",
        "c) Provision of Third Party Materials is subject to the continuing consent of the owner/licensor. Nothing in this Agreement shall obligate ADVANCE AI to continue providing access to any Services beyond the date that the owner/licensor ceases their services to ADVANCE AI. ADVANCE AI may, at its sole discretion, elect to either: (a) substitute alternative content that is similar in all material respects; or (b) terminate this Agreement with respect to such discontinued Services. ADVANCE AI will use its best effort to provide as much notice as reasonably practicable under the circumstances, in writing, prior to cessation of the discontinued Services."
      ]
    ];


    async function scanAndCommentWithPlaybook() {
      console.log("Starting scanAndCommentWithPlaybook...");

      await Word.run(async (context) => {
        const paragraphs = context.document.body.paragraphs;
        paragraphs.load("items");

        await context.sync();

        console.log("Fetching paragraphs from the document...");
        const paragraphTexts = [];

        for (let i = 0; i < paragraphs.items.length; i++) {
          const text = paragraphs.items[i].text.trim();
          if (text) {
            const cleanText = text.replace(/\s+/g, "");
            const isChinese = /[\u4e00-\u9fa5]/.test(cleanText);

            if (isChinese) {
              if (cleanText.length >= 5) {
                paragraphTexts.push({ id: i + 1, text });
                console.log(`Paragraph ${i + 1}: ${text}`);
              }
            } else {
              const wordCount = text.split(/\s+/).length;
              if (wordCount >= 5) {
                paragraphTexts.push({ id: i + 1, text });
                console.log(`Paragraph ${i + 1}: ${text}`);
              }
            }
          }
        }

        const systemPrompt = `
          You are a lawyer working on behalf of Advance AI. 
          You are reviewing a Sales agreement where Advance AI is the seller. 
          Your task is to identify provisions in the given content that match any of the rules from the playbook. 
          The content is provided as an array of paragraphs with IDs. Respond with a list of objects, each containing the paragraph ID, playbook ID, and a status (1 if exact match, 2 if similar but needs modification, 3 if no match).
          If a playbook rule matches no rules from the list of paragraphs, simply put paragraph_id to 0.

          ex:
         - paragraph_id:1, playbook_id:1, status:1  --> means paragraph 1 matches the playbook rule 1
        - paragraph_id:2, playbook_id:2, status:2  --> means paragraph 2 matches the same concept as  playbook rule 2 but the content needs to be revised
        - paragraph_id:0, playbook_id:3, status:3  --> means no paragraphs match the playbook_id 3

          
          Playbook:
          ${playbook.map((item) => `ID: ${item.id}, Rule: ${item.rule}`).join("\n")}
        `;

        const userPrompt = JSON.stringify(paragraphTexts);

        console.log("Sending to GPT the following systemPrompt content:", systemPrompt);
        console.log("Sending to GPT the following userPrompt content:", userPrompt);

        const result = await callOpenAIForPlaybookCheck(systemPrompt, userPrompt);

        if (!result) {
          console.error("No result from OpenAI");
          return;
        }

        console.log("Result from OpenAI:", result);

        let resultsTable = [];
        try {
          resultsTable = JSON.parse(result);
        } catch (parseError) {
          console.error("Failed to parse JSON response:", parseError);
          alert("Failed to parse response from OpenAI");
          return;
        }

        const missingTopics = resultsTable.filter((item) => item.status === 3).map((item) => item.playbook_id);

        for (let i = 0; i < resultsTable.length; i++) {
          const item = resultsTable[i];
          if (item.paragraph_id !== 0) {
            const paragraph = paragraphTexts.find((p) => p.id === item.paragraph_id);
            const topic = playbook.find((p) => p.id === item.playbook_id);

            if (topic) {
              const targetText = paragraph.text.substring(0, 100); // Reduce text length for search and selection
              if (item.status === 1) {
                await selectTextAndAddComment(targetText, `Exact match found: ${topic.rule}`);
                console.log(`Matching Rule: ${item.paragraph_id} with playbook ID ${item.playbook_id}`);
              } else if (item.status === 2) {
                const provisionFromTemplate = tableData.find((row) => row[0] === String(item.playbook_id))[1];
                await selectTextAndAddComment(
                  targetText,
                  `Check Rule: ${topic.rule}.\n\n Check with the following provision: ${provisionFromTemplate}`
                );
                console.log(
                  `Similar provision found for paragraph ${item.paragraph_id} with playbook ID ${item.playbook_id}. Needs modification.`
                );
              }
            } else {
              console.log(`No matching topic found for playbook ID ${item.playbook_id}`);
            }
          }
        }

        console.log(`missingTopics.length: ${missingTopics.length}`);
        console.log(`missingTopics: ${JSON.stringify(missingTopics)}`);

        if (missingTopics.length > 0) {
          const missingItems = missingTopics
            .map((id) => {
              const item = playbook.find((p) => p.id === id);
              return item ? `Rule ID: ${item.id} - ${item.rule}` : "";
            })
            .join("\n");

          const summary = `Missing Topics:\n${missingItems.replace(/\r/g, "\n")}`;
          const body = context.document.body;

          const paragraphs = summary.split("\n");

          for (const paragraph of paragraphs) {
            body.insertParagraph(paragraph, Word.InsertLocation.end);
          }

          await context.sync();
          console.log("Missing topics summary added to the document.");
        }
      }).catch((error) => {
        console.error("Error in scanAndCommentWithPlaybook:", error);
        alert("Error: " + error.message);
      });
    }


    document.getElementById("scanAndCommentWithPlaybook").addEventListener("click",
    scanAndCommentWithPlaybook);


    async function callOpenAIForPlaybookCheck(systemPrompt, userPrompt) {
      const cfg = {
        apiVersion: "2024-04-01-preview",
        modelName: "gpt4",
        apiKey: openAIKey,
        endPoint: openAIUrl,
        stream: false,
        top_p: 0,
        temperature: 0
      };

      let attempt = 0;
      const retryCount = 10;
      const initialDelay = 60000;

      while (attempt < retryCount) {
        try {
          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  { role: "system", content: systemPrompt },
                  { role: "user", content: userPrompt }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          if (response.ok) {
            const result = await response.json();
            console.log(`Result from GPT: ${JSON.stringify(result)}`);

            return result.choices[0].message.content.trim();
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }


    document.getElementById("scanAndCommentWithPlaybook").addEventListener("click",
    scanAndCommentWithPlaybook);


    async function selectTextAndAddComment(targetText, comment) {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          const searchResults = body.search(targetText, { matchCase: false, matchWholeWord: false });
          context.load(searchResults, "items");
          await context.sync();

          if (searchResults.items.length > 0) {
            const range = searchResults.items[0];
            range.select("Start");
            await context.sync();
            console.log(`Selected "${targetText}" in the document.`);

            // Add a comment to the selected text
            range.insertComment(comment, { author: "GPT-Assistant", initials: "GA" });
            await context.sync();
            console.log("Comment added successfully.");
          } else {
            console.log(`Text "${targetText}" not found.`);
          }
        });
      } catch (error) {
        console.error("Error in selectTextAndAddComment:", error);
        alert("Error: " + error.message);
      }
    }


    document.getElementById("scanAndCommentWithPlaybook").addEventListener("click",
    scanAndCommentWithPlaybook);


    async function atomemerchantplaybook() {
      const comment = document.getElementById("merchantCommentInput").value;
      const systemPrompt = `
        You are asked question from Merchants about the Merchant contract playbook. Answer those based on the information. Reject any other questions.
        Go straight to the point with no additional un-necessary prose.

        RULE 1
        15. Limitation of Liability
        15.1. To the extent permitted by law, under no circumstances shall the Indemnified Parties or you be liable to the other Party for any indirect, incidental, consequential, special or exemplary damages (whether in contract, tort, equity or otherwise), arising out of or relating to this Merchant Contract or the Assignment Agreement, the use of or inability to use the Atome Platform and/or the Atome Services, the Deferred Payment Structure, or Atome’s, the Assignee’s or your liabilities to third parties arising from any source. 
        15.2. You agree that the aggregate liability of the Indemnified Parties to you for all claims arising out of or related to this Merchant Contract or the Assignment Agreement or your use or inability to use the Atome Platform, the Atome Services, the Deferred Payment Structure, or Atome’s or the Assignee’s liabilities to third parties arising from any source, whether in tort, contract, indemnity or otherwise, will not (other than as may be required by applicable law in cases involving personal injury) exceed an amount equivalent to 50% of the Fees paid by the Merchant over the preceding 12-month period. These limitations will apply even if the above stated remedy fails of its essential purpose.

        Merchants' ask: (1) limitation of liability in 15.2 to be mutual (i.e. to apply to merchants' liability); (2) Atome's liability in 15.2 to be increased to 100% of the Fees paid

        Atome response: (1) mutuality is agreeable provided that certain liabilities (obligations under clauses 8 and 9, any clawback under clause 20.5) are carved out of the merchant's liability cap); (2) agreeable to 100% provided Atome General Manager consent is obtained.

        RULE 2
        20. Term and Termination
        20.2. Upon expiry of the Term, the Merchant Contract shall automatically renew on the same terms and conditions for successive twelve (12) month terms thereafter until and unless terminated by either Party by way of notice in writing issued to the other party no less than thirty (30) calendar days prior to the expiry of the prevailing Term.

        Merchants' ask: Contract not to be an automatic renewal basis 
        Atome response: Not possible as this is a logistical burden for account managers to track expiry and renewal of each contract. 

        RULE 3
        7. Cancellations of Transactions
        7.1.1. Atome has reason to suspect, or becomes aware, that you have breached any of your obligations under Clause 11 of this Merchant Contract or any representation and warranty made by you under Clause 12 of this Merchant Contract is incorrect or misleading; 

        Merchants' ask: To delete references to "suspects" 
        Atome response: Push to retain as this allows us greater latitude to effect a cancellation preventatively. Able to accept a reasonableness qualifier, e.g. "reasonably suspects"
      `;

      const response = await callOpenAIForPlaybookCheck(systemPrompt, comment);
      document.getElementById("gptResponseOutput").value = response;
    }


    // Function to call OpenAI API

    async function callOpenAIForPlaybookCheck(systemPrompt, userPrompt,
    retryCount = 10, initialDelay = 60000) {
      const cfg = {
        apiVersion: "2024-04-01-preview",
        modelName: "gpt4",
        systemPrompt: systemPrompt,
        userPrompt: userPrompt,
        apiKey: openAIKey,
        endPoint: openAIUrl,
        stream: false,
        top_p: 0,
        temperature: 0
      };

      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  { role: "system", content: cfg.systemPrompt },
                  { role: "user", content: cfg.userPrompt }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          if (response.ok) {
            const result = await response.json();
            return result.choices[0].message.content.trim();
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }

  language: TypeScript
template:
  content: |+
    <div id="apiKeyInputContainer">
      <input type="text" id="apiKeyInput" placeholder="Enter API Key">
      <button id="saveApiKeyButton">Save Key</button>
    </div>

    <div id="apiUrlInputContainer">
      <input type="text" id="apiUrlInput" placeholder="Enter API URL">
      <button id="saveApiUrlButton">Save URL</button>
    </div>

    <div id="mainLayout">


    <div style="margin-top: 20px;">
      Output either as a comment or at the end of the document:<br />
      <button id="leadershipReviewerButton">Leadership Reviewer</button>
      <button id="bulletPointSummarizerButton">Bullet Point Summarizer</button>
      <button id="articleWriterButton">Article Writer</button>
      <button id="fixLegalEnglishButton">Fix Legal English</button>
      <button id="ExplainLegalEnglishButton">Explain</button>

      <p />
      Output as a side by side table:<br />
      <button id="translateToChineseButton">Translate to Chinese</button>
      <button id="translateToIndonesianButton">Translate to Bahasa Indonesia</button>
      <button id="translateToEnglishButton">Translate to English</button>
      <button id="translateToThaiButton">Translate to Thai</button>
    </div>

    <p />
    Merchant contract playbook AMA (ATOME ONLY) :<br />
      <button id="atomeMerchantContractCheckButton">Switch</button>
      <br /><br />

    <p />
    Risk Assessment (whole contract -AAI ONLY) :<br />
    <button id="scanAndCommentButton">Scan via RiskBook</button>
    <button id="scanAndCommentWithPlaybook">Scan via Template Contract</button>

    <p />
    Emergency stop (reload the script after) :<br />
    <button id="hardStopButton">Hard Stop</button>

    <p />
    <p />
    <p />
    <p />
    <p />
    <p />
    ---
    <br />
    <button id="eraseCredentialsButton">Edit Credentials</button>
    </div>

    <!-- Merchant Comments Layout -->
    <div id="merchantCommentsLayout" style="display: none;">
        <button id="backButton">Back</button>
      <p />

      <label>Drop here the comment from the Merchants:</label>
      <p />
      <textarea id="merchantCommentInput" style="width: 99%; height: 150px;"></textarea>
      <p />
      <button id="submitCommentButton">Submit</button>
      <p />
      <label>Response:</label>
        <p />
      <textarea id="gptResponseOutput" style="width: 99%; height: 150px;" readonly></textarea>      <p />


    </div>

  language: HTML
style:
  content: ''
  language: CSS
libraries: |-
  https://appsforoffice.microsoft.com/lib/1/hosted/office.js
  https://appsforoffice.microsoft.com/lib/1/hosted/office.d.ts
  office-ui-fabric-js@1.4.0/dist/css/fabric.min.css
  office-ui-fabric-js@1.4.0/dist/css/fabric.components.min.css
  core-js@2.4.1/client/core.min.js
  @types/core-js
  jquery@3.1.1
  @types/jquery
