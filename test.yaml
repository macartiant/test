name: AIG Toolbox
description: AIG Toolbox
host: WORD
api_set: {}
script:
  content: >
    let openAIKey = localStorage.getItem("openAIKey") || "";

    let openAIUrl = localStorage.getItem("openAIUrl") || "";

    let stopExecution = false;


    document.addEventListener("DOMContentLoaded", function() {
      const apiKeyInputContainer = document.getElementById("apiKeyInputContainer");
      const apiUrlInputContainer = document.getElementById("apiUrlInputContainer");

      if (openAIKey && openAIUrl) {
        if (apiKeyInputContainer) apiKeyInputContainer.style.display = "none";
        if (apiUrlInputContainer) apiUrlInputContainer.style.display = "none";
      }
    });


    document.getElementById("saveApiKeyButton").addEventListener("click",
    function() {
      openAIKey = document.getElementById("apiKeyInput").value;
      localStorage.setItem("openAIKey", openAIKey);
      alert("API Key saved");
    });


    document.getElementById("saveApiUrlButton").addEventListener("click",
    function() {
      openAIUrl = document.getElementById("apiUrlInput").value;
      localStorage.setItem("openAIUrl", openAIUrl);
      alert("API URL saved");
    });


    document.getElementById("eraseCredentialsButton").addEventListener("click",
    function() {
      localStorage.removeItem("openAIKey");
      localStorage.removeItem("openAIUrl");
      openAIKey = "";
      openAIUrl = "";
      document.getElementById("apiKeyInputContainer").style.display = "block";
      document.getElementById("apiUrlInputContainer").style.display = "block";
      alert("API credentials erased");
    });


    document.getElementById("hardStopButton").addEventListener("click",
    function() {
      alert("Stopping execution");
      stopExecution = true;
    });


    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        console.log("Office is ready in Word.");
      }
    });


    async function callOpenAI(systemPrompt, handleOutput) {
      stopExecution = false; // Reset the flag at the start of the function

      if (!openAIKey || !openAIUrl) {
        alert("Please enter and save your OpenAI API key and URL.");
        return;
      }

      try {
        await Word.run(async (context) => {
          const selection = context.document.getSelection();
          context.load(selection, "text");
          await context.sync();

          let textToSend = selection.text;

          if (textToSend.length === 0) {
            const body = context.document.body;
            context.load(body, "text");
            await context.sync();
            textToSend = body.text;
          }

          const chunkSize = 8000; // Define larger chunk size
          const textChunks = [];

          // Break text into chunks at paragraph boundaries
          let paragraphs = textToSend.split("\n");
          let currentChunk = "";
          paragraphs.forEach((paragraph) => {
            if (currentChunk.length + paragraph.length + 1 > chunkSize) {
              textChunks.push(currentChunk);
              currentChunk = paragraph;
            } else {
              currentChunk += (currentChunk ? "\n" : "") + paragraph;
            }
          });
          if (currentChunk) {
            textChunks.push(currentChunk);
          }

          const responses = [];
          for (let i = 0; i < textChunks.length; i++) {
            if (stopExecution) {
              console.log("Execution stopped by user");
              throw new Error("Script execution stopped by user");
            }

            const chunk = textChunks[i];
            const cfg = {
              apiVersion: "2024-04-01-preview",
              modelName: "gpt4",
              message: chunk,
              apiKey: openAIKey,
              endPoint: openAIUrl,
              stream: false
            };

            const bodyContent = JSON.stringify({
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: cfg.message }
              ],
              stream: cfg.stream
            });

            console.log("sending to GPT the following content:", bodyContent);

            let response;
            for (let attempt = 0; attempt < 10; attempt++) {
              try {
                response = await fetch(
                  `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${cfg.apiKey}`
                    },
                    body: bodyContent
                  }
                );

                console.log("Fetch response status:", response.status, response.statusText);

                if (response.ok) {
                  break;
                } else {
                  console.error(`Attempt ${attempt + 1} failed: ${response.statusText}`);
                  if (attempt < 9) {
                    await new Promise((resolve) => setTimeout(resolve, 5000 * Math.pow(2, attempt)));
                  }
                }
              } catch (error) {
                console.error(`Attempt ${attempt + 1} error:`, error);
                if (attempt < 9) {
                  await new Promise((resolve) => setTimeout(resolve, 5000 * Math.pow(2, attempt)));
                }
              }
            }

            if (!response || !response.ok) {
              const errorText = response ? await response.text() : "No response";
              console.error("Response error text:", errorText);
              throw new Error(`Failed to fetch from OpenAI: ${response.statusText} - ${errorText}`);
            }

            const result = await response.json();
            console.log("Response JSON received:", result);

            let output;
            if (result.msg) {
              output = result.msg;
            } else if (result.choices && result.choices.length > 0) {
              output = result.choices[0].message.content;
            } else {
              throw new Error("Invalid response structure");
            }

            responses.push(output);

            // Pause for 1 second after every 5 API calls
            if ((i + 1) % 5 === 0) {
              console.log("Pausing for 1 second after 5 API calls");
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
          }

          const finalOutput = responses.join("\n\n");
          handleOutput(finalOutput);
        });
      } catch (error) {
        console.error("Error in callOpenAI:", error);
        alert("Error: " + error.message);
      }
    }


    async function appendOutputToDocument(output, isFirstChunk) {
      await Word.run(async (context) => {
        const body = context.document.body;

        if (isFirstChunk) {
          body.insertParagraph("", Word.InsertLocation.end); // Add a blank line before the GPT output
          body.insertParagraph("--- GPT output ---", Word.InsertLocation.end);
        }

        const paragraphs = output.split("\n");

        for (const paragraph of paragraphs) {
          const cleanParagraph = paragraph.replace(/\*\*/g, ""); // Remove '**'
          body.insertParagraph(cleanParagraph, Word.InsertLocation.end);
        }

        await context.sync();
      });
    }


    async function searchAndComment(output) {
      await Word.run(async (context) => {
        const selection = context.document.getSelection();
        context.load(selection, "text");
        await context.sync();

        const cleanOutput = output.replace(/\*\*/g, ""); // Remove '**'

        if (selection.text.length > 0) {
          selection.insertComment(cleanOutput, { author: "OpenAI GPT", initials: "GPT" });
          await context.sync();
          console.log("Comment added successfully.");
        } else {
          await appendOutputToDocument(cleanOutput, true);
        }
      });
    }


    function leadershipReviewer() {
      callOpenAI(
        "Make an assessment on whether or not the information should be submitted as it is to the Leader. Assume this is a submission by the Legal team. Rate from 0 to 5 and explain the reasoning. If it not a 5, rewrite to make it as a 5.",
        searchAndComment
      );
    }


    function bulletPointSummarizer() {
      callOpenAI(
        "Summarize the content and present it in bullet points. Ensure it is short to the point, only the essence. Max word per sentence: 14",
        searchAndComment
      );
    }


    function articleWriter() {
      callOpenAI(
        "As per the instructions provided, draft a clause that includes all essential elements.",
        searchAndComment
      );
    }


    function translateToIndonesian() {
      callOpenAI("Translate the following text to Bahasa Indonesia.", searchAndComment);
    }



    function fixLegalEnglish() {
      callOpenAI("Improve the legal English in the following text to make it clearer and more precise.", searchAndComment);
    }


    document.getElementById("leadershipReviewerButton").addEventListener("click",
    leadershipReviewer);

    document.getElementById("bulletPointSummarizerButton").addEventListener("click",
    bulletPointSummarizer);

    document.getElementById("articleWriterButton").addEventListener("click",
    articleWriter);

    document.getElementById("fixLegalEnglishButton").addEventListener("click",
    fixLegalEnglish);


    // New functions for batched translation

    async function callOpenAIForTranslation(content, targetLanguage, retryCount
    = 10, initialDelay = 5000) {
      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const cfg = {
            apiVersion: "2024-04-01-preview",
            modelName: "gpt4",
            message: content,
            apiKey: openAIKey,
            endPoint: openAIUrl,
            stream: false,
            top_p: 0,
            temperature: 0
          };

          // console.log(`Calling OpenAI for translation to ${targetLanguage} with config:`, cfg);

          const response = await fetch(
            `${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${cfg.apiKey}`
              },
              body: JSON.stringify({
                messages: [
                  {
                    role: "system",
                    content: `Translate the following content to ${targetLanguage}. Keep paragraph delimiters (\\r\\n, \\r, or \\n) in the output.`
                  },
                  { role: "user", content: cfg.message }
                ],
                stream: cfg.stream,
                top_p: cfg.top_p,
                temperature: cfg.temperature
              })
            }
          );

          console.log("Fetch response status:", response.status);

          if (response.ok) {
            const result = await response.json();
            console.log(`OpenAI translation result to ${targetLanguage}:`, result);
            return result.choices[0].message.content;
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI for translation to ${targetLanguage} (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }


    async function createTableWithBatchedTranslation(targetLanguage) {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          context.load(body, "text");
          await context.sync();

          const originalText = body.text;
          console.log("Original document text:", originalText);

          // Split the document content into paragraphs
          const paragraphs = originalText.split(/\r\n|\r|\n/).filter((p) => p.trim().length > 0);
          const paragraphCount = paragraphs.length;
          console.log("Number of paragraphs:", paragraphCount);

          // Clear the document content
          body.clear();

          // Prepare for translation in batches
          const batchSize = 2;

          for (let i = 0; i < paragraphCount; i += batchSize) {
            if (stopExecution) {
              console.log("Execution stopped by user.");
              return;
            }

            const batch = paragraphs.slice(i, i + batchSize).join("\n");
            console.log(`Translating batch ${i / batchSize + 1}:`, batch);
            const translatedBatch = await callOpenAIForTranslation(batch, targetLanguage);

            if (translatedBatch) {
              const translatedParagraphs = translatedBatch.split(/\r\n|\r|\n/).filter((p) => p.trim().length > 0);
              console.log(`Number of translated paragraphs: ${translatedParagraphs.length}`);

              // Ensure the lengths of paragraphs and translatedParagraphs match
              for (let j = 0; j < translatedParagraphs.length; j++) {
                if (i + j < paragraphCount) {
                  const originalParagraph = paragraphs[i + j] || "";
                  const translatedParagraph = translatedParagraphs[j] || "";

                  // Check if the original paragraph and the translated paragraph are both non-empty
                  if (originalParagraph.trim() !== "" || translatedParagraph.trim() !== "") {
                    console.log(`Original Paragraph ${i + j}:`, originalParagraph);
                    console.log(`Translated Paragraph ${i + j}:`, translatedParagraph);

                    const table = body.insertTable(1, 2, Word.InsertLocation.end, [
                      [originalParagraph, translatedParagraph]
                    ]);
                    body.insertParagraph("", Word.InsertLocation.end);

                    await context.sync();
                  }
                }
              }
            } else {
              console.log("Failed to translate batch:", batch);
              alert("Translation failed. Please try again later.");
              return;
            }
          }

          console.log("Tables created with preloaded paragraphs and translations.");
        });
      } catch (error) {
        console.error("Error in createTableWithBatchedTranslation:", error);
        alert("Error: " + error.message);
      }
    }


    document.getElementById("translateToChineseButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("Chinese");
    });



    document.getElementById("translateToIndonesianButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("Indonesian");
    });


    document.getElementById("translateToEnglishButton").addEventListener("click",
    function() {
      createTableWithBatchedTranslation("English");
    });





    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        console.log("Office is ready in Word.");
      }
    });


    async function selectText(targetText) {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          const searchResults = body.search(targetText, { matchCase: false, matchWholeWord: false });
          context.load(searchResults, 'items');
          await context.sync();

          if (searchResults.items.length > 0) {
            const range = searchResults.items[0];
            range.select("Start");
            await context.sync();
            console.log(`Selected "${targetText}" in the document.`);

            // Add a comment to the selected text
            range.insertComment("test", { author: "GPT-Assistant", initials: "GA" });
            await context.sync();
            console.log("Comment added successfully.");
          } else {
            console.log(`Text "${targetText}" not found.`);
          }
        });
      } catch (error) {
        console.error("Error in selectText:", error);
        alert("Error: " + error.message);
      }
    }


    const detailedChecklist = [
      {
        id: 1,
        risk: "Unlimited Liability",
        description: "Clauses that impose liability on the Seller for all damages arising out of or in connection with the Agreement.",
        example: "Seller will be liable for all damages arising out of or in connection with the Agreement."
      },
      {
        id: 2,
        risk: "Unfair Termination Rights",
        description: "Clauses that allow the Buyer to terminate the Agreement at any time without cause.",
        example: "Buyer may terminate the Agreement at any time without cause."
      },
      {
        id: 3,
        risk: "Intellectual Property Rights Infringement",
        description: "Clauses that require the Seller to indemnify the Buyer against all claims of intellectual property infringement.",
        example: "Seller will indemnify Buyer against all claims of IP infringement."
      },
      {
        id: 4,
        risk: "Unreasonable Warranty Obligations",
        description: "Clauses that impose unreasonable warranty obligations on the Seller.",
        example: "Seller warrants that the services will be free from defects for a period of 5 years."
      },
      {
        id: 5,
        risk: "Unfair Confidentiality Obligations",
        description: "Clauses that require the Seller to keep all information confidential indefinitely.",
        example: "Seller must keep all information confidential indefinitely."
      },
      {
        id: 6,
        risk: "Unfair Non-Compete Clause",
        description: "Clauses that restrict the Seller from providing similar services to any other company for an unreasonable period.",
        example: "Seller may not provide similar services to any other company for a period of 5 years."
      },
      {
        id: 7,
        risk: "Unreasonable Indemnification Obligations",
        description: "Clauses that require the Seller to indemnify the Buyer for any and all claims, regardless of fault.",
        example: "Seller indemnifies Buyer for any and all claims, regardless of fault."
      },
      {
        id: 8,
        risk: "Unfair Dispute Resolution Clause",
        description: "Clauses that require all disputes to be resolved in the Buyer’s home jurisdiction.",
        example: "All disputes will be resolved in the Buyer's home jurisdiction."
      },
      {
        id: 9,
        risk: "Unreasonable Service Level Agreements",
        description: "Clauses that impose unreasonable service level agreements on the Seller.",
        example: "Seller must maintain 99.999% uptime."
      },
      {
        id: 10,
        risk: "Unfair Force Majeure Clause",
        description: "Clauses that do not excuse the Seller from performance in the event of a force majeure.",
        example: "Force majeure does not excuse Seller from performance."
      },
      {
        id: 11,
        risk: "Unreasonable Audit Rights",
        description: "Clauses that allow the Buyer to audit the Seller at any time without notice.",
        example: "Buyer may audit Seller at any time without notice."
      },
      {
        id: 12,
        risk: "Unfair Payment Terms",
        description: "Clauses that impose unfair payment terms on the Seller.",
        example: "Payment is due 90 days after invoice date."
      },
      {
        id: 13,
        risk: "Unreasonable Insurance Requirements",
        description: "Clauses that require the Seller to maintain unreasonable amounts of liability insurance.",
        example: "Seller must maintain $10 million in liability insurance."
      },
      {
        id: 14,
        risk: "Unfair Assignment Clause",
        description: "Clauses that allow the Buyer to assign the Agreement without the Seller’s consent.",
        example: "Buyer may assign the Agreement without Seller's consent."
      },
      {
        id: 15,
        risk: "Unreasonable Data Security Requirements",
        description: "Clauses that require the Seller to comply with all data security standards, regardless of cost.",
        example: "Seller must comply with all data security standards, regardless of cost."
      },
      {
        id: 16,
        risk: "Unfair Change Control Process",
        description: "Clauses that allow the Buyer to make changes to the services at any time without the Seller’s consent.",
        example: "Buyer may make changes to the services at any time without Seller's consent."
      },
      {
        id: 17,
        risk: "Unreasonable Subcontracting Restrictions",
        description: "Clauses that restrict the Seller from subcontracting without the Buyer’s consent.",
        example: "Seller may not subcontract without Buyer's consent."
      },
      {
        id: 18,
        risk: "Unfair Default Clause",
        description: "Clauses that consider any breach by the Seller as a default.",
        example: "Any breach by Seller constitutes a default."
      },
      {
        id: 19,
        risk: "Unreasonable Compliance Obligations",
        description: "Clauses that require the Seller to comply with all laws in the Buyer’s jurisdiction.",
        example: "Seller must comply with all laws in Buyer's jurisdiction."
      },
      {
        id: 20,
        risk: "Unfair Pricing Adjustments",
        description: "Clauses that allow the Buyer to adjust pricing at any time.",
        example: "Buyer may adjust pricing at any time."
      }
    ];


    const systemPrompt = `

    You are a contract review assistant. Your task is to identify provisions in
    the given paragraph that match any of the following risks. 

    For each risk, I have provided a detailed description and an example.
    Respond with the ID of the risk if a match is found, otherwise return 0.

    Checklist:

    ${detailedChecklist.map(item => `- ID: ${item.id} - ${item.risk}:
    ${item.description}\nExample: ${item.example}`).join("\n\n")}

    Example:

    1

    `;


    const systemPrompt = `

    You are a contract review assistant. Your task is to identify provisions in
    the given paragraph that match any of the following risks. 

    For each risk, I have provided a detailed description and an example.
    Respond with the ID of the risk if a match is found, otherwise return 0.

    Checklist:

    ${detailedChecklist.map(item => `- ID: ${item.id} - ${item.risk}:
    ${item.description}\nExample: ${item.example}`).join("\n\n")}

    Example:

    1

    `;


    async function checkParagraphForRisks(paragraph, retryCount = 10,
    initialDelay = 60000) {
      const userPrompt = paragraph;

      const cfg = {
        apiVersion: '2024-04-01-preview',
        modelName: "gpt4",
        systemPrompt: systemPrompt,
        userPrompt: userPrompt,
        apiKey: openAIKey,
        endPoint: openAIUrl,
        stream: false,
        top_p: 0,
        temperature: 0,
      };

      let attempt = 0;
      while (attempt < retryCount) {
        try {
          const response = await fetch(`${cfg.endPoint}/openai/deployments/${cfg.modelName}/chat/completions?api-version=${cfg.apiVersion}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${cfg.apiKey}`,
            },
            body: JSON.stringify({
              messages: [
                { role: 'system', content: cfg.systemPrompt },
                { role: 'user', content: cfg.userPrompt }
              ],
              stream: cfg.stream,
              top_p: cfg.top_p,
              temperature: cfg.temperature
            }),
          });

          if (response.ok) {
            const result = await response.json();
            console.log(`Result from GPT: ${result}`);
            
            
            return result.choices[0].message.content.trim();
          } else {
            throw new Error(`Failed to fetch from OpenAI: ${response.statusText}`);
          }
        } catch (error) {
          console.error(`Error calling OpenAI (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt < retryCount) {
            const delay = initialDelay * Math.pow(2, attempt - 1);
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          } else {
            return null;
          }
        }
      }
    }


    async function scanAndComment() {
      try {
        await Word.run(async (context) => {
          const body = context.document.body;
          const paragraphs = body.paragraphs;
          context.load(paragraphs, 'items');
          await context.sync();

          for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            const range = paragraph.getRange();
            context.load(range, 'text');
            await context.sync();

            const text = range.text.trim().replace(/\s+/g, '');
            const isChinese = /[\u4e00-\u9fa5]/.test(text);

            if (isChinese) {
              // Count characters for Chinese
              if (text.length < 5) {
                continue;
              }
            } else {
              // Count words for other languages
              const wordCount = range.text.trim().split(/\s+/).length;
              if (wordCount < 5) {
                continue;
              }
            }

            console.log(`Text length or word count for paragraph ${i + 1}:`, isChinese ? text.length : range.text.trim().split(/\s+/).length);

            range.select();
            await context.sync();

            const result = await checkParagraphForRisks(range.text);
            console.log(`Querying GPT for paragraph: ${range.text}`);
            console.log(`Result from GPT: ${result}`);

            if (result && result !== '0') {
              const riskId = parseInt(result, 10);
              const risk = detailedChecklist.find(item => item.id === riskId);
              if (risk) {
                range.insertComment(`Risk: ${risk.risk}`, { author: "GPT-Assistant", initials: "GA" });
                await context.sync();
              }
            }

            console.log(`Processed paragraph ${i + 1}`);
          }
        });
      } catch (error) {
        console.error("Error in scanAndComment:", error);
        alert("Error: " + error.message);
      }
    }


    document.getElementById("scanAndCommentButton").addEventListener("click",
    scanAndComment);
  language: TypeScript
template:
  content: |-
    <div id="apiKeyInputContainer">
      <input type="text" id="apiKeyInput" placeholder="Enter API Key">
      <button id="saveApiKeyButton">Save Key</button>
    </div>
    <div id="apiUrlInputContainer">
      <input type="text" id="apiUrlInput" placeholder="Enter API URL">
      <button id="saveApiUrlButton">Save URL</button>
    </div>

    <div style="margin-top: 20px;">
     Output either as a comment or at the end of the document:<br />

      <button id="leadershipReviewerButton">Leadership Reviewer</button>
      <button id="bulletPointSummarizerButton">Bullet Point Summarizer</button>
      <button id="articleWriterButton">Article Writer</button>
      <button id="fixLegalEnglishButton">Fix Legal English</button>

    <p />
     Output as a side by side table:<br>


      <button id="translateToChineseButton">Translate to Chinese</button>
          <button id="translateToIndonesianButton">Translate to Bahasa Indonesia</button>

      <button id="translateToEnglishButton">Translate to English</button>
    </div>

    <p />
    Risk Assessment (whole contract) :<br/>


      <button id="scanAndCommentButton">Scan via playbook</button>

    <p />
    Emergency stop (reload the script after) :<br/>
    <button id="hardStopButton">Hard Stop</button>




    <p />
    <p />
    <p />
    <p />
    <p />
    <p />

    ---<br/>

    <button id="eraseCredentialsButton">Edit Credentials</button>
  language: HTML
style:
  content: ''
  language: CSS
libraries: |-
  https://appsforoffice.microsoft.com/lib/1/hosted/office.js
  https://appsforoffice.microsoft.com/lib/1/hosted/office.d.ts
  office-ui-fabric-js@1.4.0/dist/css/fabric.min.css
  office-ui-fabric-js@1.4.0/dist/css/fabric.components.min.css
  core-js@2.4.1/client/core.min.js
  @types/core-js
  jquery@3.1.1
  @types/jquery
